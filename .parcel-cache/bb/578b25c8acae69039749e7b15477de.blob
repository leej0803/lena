var _parcelHelpers = require("@parcel/transformer-js/lib/esmodule-helpers.js");
_parcelHelpers.defineInteropFlag(exports);
_parcelHelpers.export(exports, "PlaneTextureLoader", function () {
  return PlaneTextureLoader;
});
var _TextureLoaderJs = require("./TextureLoader.js");
var _utilsUtilsJs = require("../utils/utils.js");
class PlaneTextureLoader extends _TextureLoaderJs.TextureLoader {
  constructor(renderer, parent, {sourcesLoaded = 0, sourcesToLoad = 0, complete = false, onComplete = () => {}} = {}) {
    super(renderer, parent.crossOrigin);
    this.type = "PlaneTextureLoader";
    this._parent = parent;
    if (this._parent.type !== "Plane" && this._parent.type !== "PingPongPlane" && this._parent.type !== "ShaderPass") {
      _utilsUtilsJs.throwWarning(this.type + ": Wrong parent type assigned to this loader");
      this._parent = null;
    }
    this.sourcesLoaded = sourcesLoaded;
    this.sourcesToLoad = sourcesToLoad;
    this.complete = complete;
    this.onComplete = onComplete;
  }
  /*** TRACK LOADING ***/
  /***
  Sets the total number of assets to load before firing the onComplete event
  
  params:
  @size (int): our curtains object OR our curtains renderer object
  ***/
  _setLoaderSize(size) {
    this.sourcesToLoad = size;
    if (this.sourcesToLoad === 0) {
      this.complete = true;
      this.renderer.nextRender.add(() => this.onComplete && this.onComplete());
    }
  }
  /***
  Increment the number of sources loaded
  ***/
  _increment() {
    this.sourcesLoaded++;
    if (this.sourcesLoaded >= this.sourcesToLoad && !this.complete) {
      this.complete = true;
      this.renderer.nextRender.add(() => this.onComplete && this.onComplete());
    }
  }
  /*** UPDATE PARENT SOURCES AND TEXTURES ARAYS ***/
  /***
  Adds the source to the correct parent assets array
  
  params:
  @source (html element): html image, video or canvas element that has been loaded
  @sourceType (string): either "image", "video" or "canvas"
  ***/
  _addSourceToParent(source, sourceType) {
    // add the source if it is not already in the correct parent assets array
    if (sourceType === "image") {
      const parentAssetArray = this._parent["images"];
      const isInParent = parentAssetArray.find(element => element.src === source.src);
      !isInParent && parentAssetArray.push(source);
    } else if (sourceType === "video") {
      const parentAssetArray = this._parent["videos"];
      const isInParent = parentAssetArray.find(element => element.src === source.src);
      !isInParent && parentAssetArray.push(source);
    } else if (sourceType === "canvas") {
      const parentAssetArray = this._parent["canvases"];
      const isInParent = parentAssetArray.find(element => element.isSameNode(source));
      !isInParent && parentAssetArray.push(source);
    }
  }
  /***
  Adds the loader parent to the newly created texture
  Also adds the source to the correct parent assets array
  
  params:
  @texture (Texture class object): our newly created texture
  @source (html element): html image, video or canvas element that has been loaded
  @sourceType (string): either "image", "video" or "canvas"
  ***/
  _addToParent(texture, source, sourceType) {
    this._addSourceToParent(source, sourceType);
    // add the texture to the parent
    this._parent && texture.addParent(this._parent);
  }
}
